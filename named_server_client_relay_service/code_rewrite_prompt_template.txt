i have the following code that i want you to rewrite.

the code has four python files,

- relay_server.py, providing named socket relay service
- client_service_provider.py, will create a named socket client and connect to relay server, relay traffic to target server
- client_service_user.py, will create a named socket client and connect to relay server, relay traffic to clients connected to a server listening for connections
- utils.py, utilities for socket communication and logging

i want you to ...

relay_server.py:

```python
import socket
import threading
# import sys
from utils import timed_print, pipe_thread

# it is hard to say if the ai has improved, but the code is different, and we may want to try before changing the code manually

# the relay server need to either buffer the data from the service provider or only invoke connection when the client connects.
# record connection ids to enable multi connections.
# otherwise we cannot ensure vnc connection established after the client connects to the relay server.

class RelayServer:
    def __init__(self, host, port):
        self.host = host
        self.port = port
        # Dictionary to map service names to provider sockets
        self.service_registry = {}
        self.lock = threading.Lock()

    def start(self):
        """Start the relay server to listen for connections"""
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        # self.sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
        self.sock.bind((self.host, self.port))
        self.sock.listen(10)
        timed_print(f"Relay server listening on {self.host}:{self.port}")

        try:
            while True:
                client_sock, client_addr = self.sock.accept()
                timed_print(f"New connection from {client_addr}")
                # Handle each connection in a new thread
                client_thread = threading.Thread(target=self.handle_connection, args=(client_sock,))
                client_thread.daemon = True
                client_thread.start()
        except KeyboardInterrupt:
            timed_print("Server is shutting down.")
        finally:
            self.sock.close()

    def handle_connection(self, sock):
        """Handle initial communication to identify service provider or client"""
        try:
            # Initial identification message
            ident_data = sock.recv(1024).decode('utf-8').strip()
            timed_print(f"Received identification: {ident_data}")

            if ident_data.startswith("REGISTER:"):
                # This is a service provider registering a service
                service_name = ident_data.split(":")[1]
                self.register_service(service_name, sock)
            elif ident_data.startswith("REQUEST:"):
                # This is a client requesting a service
                service_name = ident_data.split(":")[1]
                self.handle_client_request(service_name, sock)
            else:
                timed_print(f"Unknown protocol message: {ident_data}")
                sock.close()
        except Exception as e:
            timed_print(f"Error handling connection: {e}")
            sock.close()

    def register_service(self, service_name:str, provider_sock:socket.socket):
        """Register a service provider in the registry"""
        with self.lock:
            if service_name in self.service_registry:
                timed_print(f"Service '{service_name}' is already registered. Closing old connection.")
                old_sock = self.service_registry[service_name]
                try:
                    old_sock.shutdown(socket.SHUT_RDWR)
                    old_sock.close()
                except: pass
            self.service_registry[service_name] = provider_sock
            timed_print(f"Service '{service_name}' registered successfully.")

    def unregister_service(self, service_name, provider_sock):
        """Remove a service from the registry when the provider disconnects"""
        with self.lock:
            if service_name in self.service_registry and self.service_registry[service_name] is provider_sock:
                try:
                    provider_sock.shutdown(socket.SHUT_RDWR)
                    provider_sock.close()
                except: pass
                del self.service_registry[service_name]
                timed_print(f"Service '{service_name}' unregistered.")

    def handle_client_request(self, service_name, client_sock):
        """Handle a client request by connecting it to the registered service provider"""
        with self.lock:
            provider_sock = self.service_registry.get(service_name)

        if provider_sock is None:
            timed_print(f"Client requested unknown service: {service_name}")
            client_sock.sendall(b"ERROR:Service not found")
            client_sock.close()
            return

        timed_print(f"Connecting client to service '{service_name}'")
        client_sock.sendall(b"OK")
        # Create the bidirectional pipe between client and service provider
        threads = self.create_bidirectional_pipe(client_sock, provider_sock)
        for t in threads:
            t.join()
        timed_print(f"Client disconnected from service '{service_name}'")
        self.unregister_service(service_name, provider_sock)

    def create_bidirectional_pipe(self, sock1, sock2):
        """Create two threads to relay data bidirectionally between two sockets"""

        # Start threads for both directions
        thread1 = threading.Thread(target=pipe_thread, args=(sock1, sock2, "sock1_sock2"))
        thread2 = threading.Thread(target=pipe_thread, args=(sock2, sock1, "sock2_sock1"))
        thread1.daemon = True
        thread2.daemon = True
        thread1.start()
        thread2.start()
        threads = [thread1, thread2]
        return threads

if __name__ == "__main__":
    relay = RelayServer('0.0.0.0', 8888)
    relay.start()
```

client_service_provider.py:

```python
import socket
import threading
from utils import timed_print, pipe_thread

def start_service_provider(
    relay_host: str,
    relay_port: int,
    service_name: str,
    target_host: str,
    target_port: int,
):
    # Connect to the relay server
    relay_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # relay_sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    relay_sock.connect((relay_host, relay_port))

    # Register as a service provider
    registration_msg = f"REGISTER:{service_name}"
    relay_sock.sendall(registration_msg.encode("utf-8"))
    timed_print(f"Registered service '{service_name}' with relay")
    connect_msg = relay_sock.recv(1024)
    timed_print(f"Received %s init bytes from relay" % len(connect_msg))
    if connect_msg == b"CONNECT":
        timed_print("Relay is ready to connect")
        # This socket now acts as a bridge to the relay
        # In a more advanced version, you could automatically connect to the local service (e.g., localhost:5900)
        # and pipe data between `relay_sock` and the local service socket.
        service_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        service_sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
        service_sock.connect((target_host, target_port))
        thread1 = threading.Thread(
            target=pipe_thread, args=(relay_sock, service_sock, "relay_service"), daemon=True
        )
        thread2 = threading.Thread(
            target=pipe_thread, args=(service_sock, relay_sock, "service_relay"), daemon=True
        )

        thread1.start()
        thread2.start()
        # wait
        thread1.join()
        thread2.join()
    else:
        timed_print(f"Client failed to connect to relay: {connect_msg.hex()[:20]}")


if __name__ == "__main__":
    # Example: start a service provider for 'http_service_a' on port 8888
    while True:
        # start_service_provider("localhost", 8888, "http_service_a", "localhost", 8288)
        start_service_provider("localhost", 8888, "vnc_service_a", "localhost", 5950)
        timed_print("Client or relay disconnected. Reconnecting")
```

client_service_user.py:

```python
import socket
import threading

from utils import timed_print, pipe_thread

def connect_to_relay(relay_host, relay_port, service_name):
    # Connect to the relay server
    relay_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    relay_sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    relay_sock.connect((relay_host, relay_port))

    # Request the service by name
    request_msg = f"REQUEST:{service_name}"
    relay_sock.sendall(request_msg.encode("utf-8"))

    # Check for initial response
    initial_response = relay_sock.recv(1024)
    if initial_response.startswith(b"ERROR"):
        timed_print(f"Failed to connect to service: {initial_response.decode()}")
        relay_sock.close()
        return None
    if initial_response.startswith(b"OK"):
        timed_print(f"Connected to service '{service_name}' via relay")
    else:
        timed_print(f"Unexpected response from relay: {initial_response.decode()}")
        relay_sock.close()
        return None
    return relay_sock



def start_client(relay_host, relay_port, service_name, local_port:int):
    local_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # local_sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
    try:
        local_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        local_sock.bind(("localhost", local_port))
        local_sock.listen(1)
        timed_print(f"Local forwarder listening on localhost:{local_port}")

        relay_sock = connect_to_relay(relay_host, relay_port, service_name)
        try:
            client_sock, addr = local_sock.accept()
            timed_print(f"Local client connected from {addr}")
            if relay_sock is None:
                # close the client sock
                client_sock.close()
                return
            relay_sock.sendall("CONNECT".encode())
            thread1 = threading.Thread(target=pipe_thread, args=(client_sock, relay_sock, "client_relay"), daemon=True,)
            thread2 = threading.Thread(
                target=pipe_thread,
                args=(relay_sock, client_sock, "relay_client"),
                daemon=True,
            )
            # ready_msg = relay_sock.recv(1024)
            # timed_print("Received message:")
            # if ready_msg != b"PROVIDER_READY":
            #     timed_print("Provider is not ready")
            #     return
            thread1.start()
            thread2.start()
            thread1.join()
            thread2.join()
        finally:
            try:
                if relay_sock is not None:
                    relay_sock.shutdown(socket.SHUT_RDWR)
                    relay_sock.close()
            except: pass
            try:
                client_sock.shutdown(socket.SHUT_RDWR)
                client_sock.close()
            except: pass
    finally:
        local_sock.close()


if __name__ == "__main__":
    # Connect to "http_service_a" and create local port 18800
    # start_client("localhost", 8888, "http_service_a", 18800)
    while True:
        start_client("localhost", 8888, "vnc_service_a", 15900)
        timed_print("Connection aborted. Retrying...")
    # Keep the main thread alive
```

utils.py:

```python
import time
import socket

def pipe_thread(source:socket.socket, destination:socket.socket, name:str):
    timed_print("Running pipe thread:", name)
    try:
        while True:
            timed_print("Receiving data at pipe thread", name)
            data = source.recv(4096)
            timed_print("Received %s bytes at pipe thread" % len(data), name)
            # print hex repr
            timed_print("Received bytes at pipe thread %s" % name, data.hex()[:20] + ("..." if len(data.hex()) > 20 else ""))
            # init bytes from vnc server: 0a
            # although the service send 1 byte to relay, the relay does not forward the data, result into no response in client side.
            if not data:
                break
            timed_print("Sending data at pipe thread", name)
            destination.sendall(data) # send immediately
    except Exception as e:
        timed_print(f"Pipe thread %s error: {e}" % name)
    finally:
        try:
            source.shutdown(socket.SHUT_RDWR)
            source.close()
        except: pass
        try:
            destination.shutdown(socket.SHUT_RDWR)
            destination.close()
        except: pass
def timed_print(*args, **kwargs):
    timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
    print(f"[{timestamp}]", *args, **kwargs)
```